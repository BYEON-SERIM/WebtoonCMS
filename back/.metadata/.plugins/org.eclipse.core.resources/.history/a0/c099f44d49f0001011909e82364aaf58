package com.example.cms.service;

import com.example.cms.domain.Webtoon;
import com.example.cms.dto.WebtoonRequest;
import com.example.cms.repository.WebtoonRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
@RequiredArgsConstructor
@Transactional(readOnly = true) // 기본적으로 읽기 전용으로 설정 (성능 최적화)
public class WebtoonService {

    private final WebtoonRepository webtoonRepository;

    public List<Webtoon> findAll() {
        return webtoonRepository.findAll();
    }

    @Transactional // 쓰기 작업이므로 따로 선언
    public Webtoon update(Long id, WebtoonRequest dto) {
        Webtoon webtoon = webtoonRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("작품 없음"));

        // 비즈니스 로직: 데이터 수정
        webtoon.setTitle(dto.getTitle());
        webtoon.setAuthor(dto.getAuthor());
        webtoon.setGenre(dto.getGenre());
        webtoon.setStatus(dto.getStatus());
        webtoon.setDescription(dto.getDescription());
        webtoon.setTags(dto.getTags());

        // 비즈니스 로직: 예약 시간 처리
        if ("발행예약".equals(dto.getStatus())) {
            webtoon.setScheduledAt(dto.getScheduledAt());
        } else {
            webtoon.setScheduledAt(null);
        }

        if (dto.getViewCount() != null) {
            webtoon.setViewCount(dto.getViewCount());
        }

        // JPA의 Dirty Checking 덕분에 따로 save()를 안 해도 트랜잭션 종료 시 업데이트됨
        return webtoon;
    }

    @Transactional
    public Webtoon save(WebtoonRequest dto) {
        Webtoon webtoon = new Webtoon();
        webtoon.setTitle(dto.getTitle());
        webtoon.setAuthor(dto.getAuthor());
        // ... 필요한 필드 매핑 ...
        
        if (webtoon.getViewCount() == null) webtoon.setViewCount(0L);
        if (webtoon.getSortOrder() == null) {
            webtoon.setSortOrder((int) webtoonRepository.count() + 1);
        }
        
        return webtoonRepository.save(webtoon);
    }
}